# 力扣刷题整理

## 1  数组

### 1.1  704二分查找等于某个值的元素

注意查找的是左闭右闭区间还是左闭右开区间，如果是左闭右闭那么循环的条件是

for left <= right

left = mid + 1 或right = mid - 1

由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 O(logn)            log n < n

 ```go
func search(nums []int, target int) int {
	n := len(nums)
	if n == 0 {
		return -1
	}
	left, right := 0, n-1
	mid := 0
	for left <= right {
		mid = (left + right) / 2 //数据过大时用 mid := left + (right-left)/2
		if nums[mid] < target {
			left = mid + 1
		} else if target < nums[mid] {
			right = mid - 1
		} else {
			return mid
		}
	}
	return -1
}
 ```

```c#
using System;

class Program
{
    static int Search(int[] nums, int target)
    {
        if (nums.Length == 0)
        {
            return -1;
        }

        int left = 0;
        int right = nums.Length - 1;

        while (left <= right)
        {
            int mid = (left + right) / 2; // 或者使用 mid := left + (right - left) / 2
            if (nums[mid] < target)
            {
                left = mid + 1;
            }
            else if (target < nums[mid])
            {
                right = mid - 1;
            }
            else
            {
                return mid;
            }
        }

        return -1;
    }
    static void Main()
    {
        int[] nums = { 1, 2, 3, 4, 5, 7, 9, 10 };
        int a = Search(nums, 7);
        Console.WriteLine(a); // 输出: 5
    }
}

```

```java
public class BinarySearch {
    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4, 5, 7, 9, 10};
        int result = search(nums, 7);
        System.out.println(result);
    }
    
    public static int search(int[] nums, int target) {
        if (nums.length == 0) {
            return -1;
        }
        
        int left = 0;
        int right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (target < nums[mid]) {
                right = mid - 1;
            } else {
                return mid;
            }
        }
        
        return -1;
    }
}

```



### 1.2  27移除等于某个值的全部元素

用双指针，前一个指针判断是否等要移除的值，后一个指针是修改后数组的长度（后指针，前指针--->）

前一个指针遍历完一遍整个数组，用for range

后一个指针用来指向需要修改的位置

```go
func removeElement(nums []int, val int) int {
	n := len(nums)
	if n == 0 {
		return -1
	}
	back := 0
	for _, v := range nums {
		if v != val {
			nums[back] = v
			back++
		}
	}
	return back
}
```

```java
class Solution {
    public static int removeElement(int[] nums, int val) {
        if (nums == null || nums.length == 0) {
        return 0;
    }
        int back = 0;
        for (int v : nums) {
            if (v != val) {
                nums[back] = v;
                back++;
            }
        }
        return back;
    }
}
```

### 1.3  977有序数组的平方后排序(平方前有正负数）

利用双指针，一个指头，一个指尾

两指针所指的数平方后比较，谁大谁从后向前先加入结果数组，指针移一位

 ```go
func sortedSquares(nums []int) []int {
	n := len(nums)
	result := make([]int, n)
	left, right := 0, n-1
	for left <= right {
		leftValue := nums[left]*nums[left]
		rightValue := nums[right] * nums[right]
		if leftValue < rightValue {
			result[n-1] = rightValue
			n--
			right--
		} else {
			result[n-1] = leftValue
			n--
			left++
		}
	}
	return result
}
 ```



## 2  字符串

### 2.1  1047删除字符串中的所有相邻重复项

把字符切片当作栈来使用

逐步遍历字符串的字符，与字符切片的最后一个元素（栈顶）一样的则从字符切片里删除这个元素，依次遍历完字符串

 ```go
func removeDuplicates(S string) string {
	stack := []rune{}

	for _, v := range S {//for range 遍历字符串，v默认是rune类型的				
		if len(stack) > 0 && stack[len(stack)-1] == v {
			stack = stack[:len(stack)-1]
		} else {
			stack = append(stack, v)
		}
	}
	return string(stack)
}
 ```



## 3  链表

### 3.1  24两辆交换链表中的节点

cur=dummyHead;如果cur.Next!=nil&&cur.Next.Next!=nil利用cur交换cur后面的两节点（需设置临时指针）；然后cur往后移两位再做相同的事

```go
func swapPairs(head *ListNode)*ListNode{
	dummyHead:=&ListNode{Val:0,Next:head}//设置虚拟头节点
	cur:=dummyHead
	tmp1:=new(ListNode)
	tmp2:=new(ListNode)

	for cur.Next!=nil&&cur.Next.Next!=nil{
		tmp1 = cur.Next
		tmp2 = cur.Next.Next
		cur.Next = tmp2
		tmp1.Next = tmp2.Next
		tmp2.Next = tmp1

		cur = cur.Next.Next
	}
	return dummyHead.Next
}
```

### 3.2  206反转链表

需要三个指针：pre2->pre1->head  转换后：pre2<-pre1<-head (需要在最后的节点往回推)

```go
func reverseList(head *ListNode) *ListNode {
    var pre1, pre2 *ListNode
    pre2 = nil

    for head != nil {
        pre1 = head
        head = head.Next
        pre1.Next = pre2
        pre2 = pre1
    }

    return pre1
}
```



## 4  二叉树

>  链式存储：二叉树的子树一般用左右指针表示；线性存储：i的左孩子：2i+1，右孩子：2i+2。

| 二叉树种类     | 描述                            |
| -------------- | ------------------------------- |
| 满二叉树       | 根和节点都满                    |
| 完全二叉树     | 最后一层不一定满，其它层都满    |
| 二叉搜索树     | 所有节点满足：左小于中小于右    |
| 平衡二叉搜索树 | 左子树和右子树的高度差不能超过1 |
| 红黑树         | 自平衡二叉搜索树                |

**遍历方式**

* 深度优先搜索DFS（前中后序遍历），一般使用递归法和迭代法（使用栈，先不学）
* 广度优先搜索BFS（层序），迭代法（使用队列）

代码随想录网站515题还没有看完

### 4.1  前中后序遍历

```go
//type TreeNode struct {
//     Val int
//     Left *TreeNode
//     Right *TreeNode
//}
 
func preorderTraversal(root *TreeNode) []int {
    var result []int
    traverse(root, &result)
    return result
}

//前序遍历(中->左->右)
func traverse(node *TreeNode, result *[]int) {
    if node == nil {
        return
    }
    *result = append(*result, node.Val)
    traverse(node.Left, result)
    traverse(node.Right, result)
}

//中序遍历(左->中->右)
func traverse(node *TreeNode, result *[]int) {
    if node == nil {
        return
    }
    traverse(node.Left, result)
    *result = append(*result, node.Val)
    traverse(node.Right, result)
}

//后序遍历(左->右->中)
func traverse(node *TreeNode, result *[]int) {
    if node == nil {
        return
    }
    traverse(node.Left, result)
    traverse(node.Right, result)
    *result = append(*result, node.Val)
}
```

### 4.2 102层序遍历

> 用切片模拟队列
> 把根节点入队，拿出的时候记录根节点的Value并把第二层的节点入队，当拿出第二层的节点时记录Value并把第三层的节点入队...以此类推，知道队列为空。

```go
func levelOrder(root *TreeNode) [][]int {
    var result [][]int
    if root == nil {
        return result
    }

    queue := []*TreeNode{root}
    for len(queue) > 0 {
        levelSize := len(queue)
        var levelValues []int

        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]
            levelValues = append(levelValues, node.Val)

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        result = append(result, levelValues)
    }

    return result
}
```

### 4.3  515在树的每一层寻找最大值

```go
func largestValues(root *TreeNode) []int {
	var result []int
	if root == nil {
		return result
	}

	queue := []*TreeNode{root}
	for len(queue) > 0 {
		levelSize := len(queue)
		maxVal := queue[0].Val

		for i := 0; i < levelSize; i++ {
			node := queue[0]
			queue = queue[1:]

			if(maxVal<node.Val){
				maxVal = node.Val
			}

			if node.Left != nil {
				queue = append(queue, node.Left)
			}
			if node.Right != nil {
				queue = append(queue, node.Right)
			}
		}
		result = append(result, maxVal)
	}
	return result
}
```



## 5  递归

**写递归题三部曲：**

* 确定递归的参数和返回值
* 确定终止条件（一般是遍历到null返回）
* 确定单层递归的逻辑（前中后）

## 6  回溯算法 

**写回溯算法思路：**

* 回溯就是递归终止的过程，可以模拟为在n叉树上操作

* 回溯算法可以解决：组合（无序）、排列（有序）、切割、子集、棋盘（N皇后和解数独）

* 回溯算法一般名为backtracking（），参数可以在写函数逻辑的时候再看需要哪些参数

* 一定会有终止条件，一般在此处收集结果之后return

* 回溯算法的一般结构：

  ```go
  func backtracking(参数){
      if 终止条件{
          结果收集 + return
      }
      
      for 遍历集合{
          处理节点
          递归函数
          回溯操作（撤销处理节点）
          return
      }
  }
  ```


77（要求会默写）组合：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合，顺序任意。

```go
func combine(n int, k int) [][]int {
    var result [][]int
    var path []int

    var backtrack func(start, k int)
    backtrack = func(start, k int) { 	//start是在数组里开始遍历的位置，k表示需要收集的数量
        							  //当k==0时，表示不需要再收集了，可以把path添加到result了
        if k == 0 {
            temp := make([]int, len(path))//注意：copy之前需要make申请长度和容量，有容量才有值
            copy(temp, path)			//需要注意这个copy，如果直接append的话会导致地址引用混乱
            result = append(result, temp)
            return
        }

        for i := start; i <= n; i++ {
            path = append(path, i)
            backtrack(i+1, k-1)
            path = path[:len(path)-1]	//回溯
        }
    }

    backtrack(1, k)
    return result
}
```



## 7  贪心

局部最优

每次都选一个最大的，或最好的

结果是否最优：只能推理一下，本问题的局部最优是否能退出全局最优

## 8  动态规划

>  动态规划可以解决的问题：背包问题、打家劫舍、股票问题、子序列问题

**动态规划步骤：**

1. 搞清楚dp数组及下标的含义
2. 递推公式
3. dp数组如何初始化
4. 遍历顺序
5. 打印dp数组

### 8.1  509斐波那契数列：

初始化：dp[0]=0,dp[1]=1

第n个数dp[n] = dp[n-2]+ dp[n-1]

```go 
//递归解决法
//递归树有n层，第n层有1个节点，第n-1层有1*2个节点，第n-2层有1*2*2个节点...第一层有1*2*2*...*2(n-1个2相乘)个节点，全部层加起来一共有2^n个递归节点，所以这个算法的时间复杂度是O(2^n)
func fib(n int) int {
	if n < 2 {
		return n
	} else {
		return fib(n-1) + fib(n-2)
	}
}

//迭代解法
//只循环了一次，所以时间复杂度为O(n)
func fib(n int) int {
	if n < 2 {
		return n
	}
	a, b, r := 0, 1, 0
	for i := 2; i <= n; i++ {
		r = a + b
		a = b
		b = r
	}
	return r
}
```

### 8.2  70爬楼梯（每次只能爬1或2阶）

> 解法和斐波那契数列一致，只是初始化不一样而已

初始化：dp[0]=1,dp[1]=1,dp[2]=2

第n个数dp[n] = dp[n-2]+ dp[n-1]

### 8.3  746 最小花费爬楼梯

> dp[i]是到达第i阶的最小花费，包括第i阶上的花费，所以dp[i]等于dp[i-1]和dp[i-2]中的较小值加上cost[i]
>
> 因为踩到顶层为dp[n] = min(dp[n-1],dp[n-2])+cost[n]，因为cost[n]没有值，所以找到dp[n-1]和dp[n-2]的较小值即可。而dp[n-1]和dp[n-2]又可以依次往下推理
>
> dp[i] = min(dp[i-1], dp[i-2]) + cost[i]

```go 
func minCostClimbingStairs(cost []int) int {
    n := len(cost)
    dp := make([]int, n)

    dp[0], dp[1] = cost[0], cost[1]
    for i := 2; i < n; i++ {
        dp[i] = min(dp[i-1], dp[i-2]) + cost[i]
    }

    return min(dp[n-1], dp[n-2])
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

```

### 8.4   62不同路径

> 初始化：因为只能向左或向右，所以到达第一行或第一列中的每一格的路径只有一个，把它们初始化为1。

> 递推公式：dp\[i][j] = dp\[i-1][j] + dp\[i][j-1]。（到达第\[i][j]格的路径等于到它左边格子的路径加上到达它上边格子的路径。

```go 
func uniquePaths(m int, n int) int {
    dp := make([][]int, m)
    for i := range dp {			//初始化
        dp[i] = make([]int, n)
        dp[i][0] = 1
    }
    for j := 0; j < n; j++ {	 //初始化
        dp[0][j] = 1
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }

    return dp[m-1][n-1]
}
```