like 模糊查询和范围查询的原理

1. 多版本控制（MVCC），结合事务隔离级别



# MySQL

## 1  MySQL面试题
### 1.1 MySQL三范式
* 一范式：有主键，列不可再分；
* 二范式：列依赖全部主键；
*  三范式：非主键互不依赖。

### 1.2  执行顺序：from->join->where->group by->select->order by->limit
先是from和join把要查询的表迪卡儿乘积变成虚表 --> 用where对上述虚表进行筛选 --> 筛选之后用group by进行分组 --> 再用having对分组之后进行聚合筛选 --> select选择要返回的单列 --> order by对返回内容进行排序 --> limit对排序之后的内容限制行数后再显示

### 1.3  group by-分组查询
分组查询时select里的字段一般为分组字段和聚合函数，查询其他字段无任何意义。
按多段分组记录条数就是分组内所有种类的笛卡尔乘积。

### 1.4  where与having区别：
* 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。
* 判断条件不同：where不能对聚合函数进行判断，而having可以。

> having只能对分组的字段和聚合函数做判断。

### 1.5  有几种约束（6种）
主键、外键、非空、唯一、默认、检查约束

### 1.6  删除更新行为（5种）
|     | 行为        | 作用                   |
| --- | ----------- | ---------------------- |
| 1   | no action   | 有外键不允许删除       |
| 3   | cascade     | 级联，父表删子表也删   |
| 4   | set null    | 父表删，子表变为null   |
| 5   | set default | 父表删，子表变为默认值 |

### 1.7  多表查询
1. 交叉连接：生成两个表的笛卡尔乘积，占用空间大，没有实际意义，不常用。
2. 内连接join（显、隐），
3. 外连接left join（左、右）
4. 自连接（内、外）

> 内连接是交集，左外连接是左边和交集，自连接可以是内外连接

5. 子查询：将一个查询的结果作为另一个查询的条件或源表。子查询可以出现在select，from，where，having，order by等子句中，也可以用in，exists，any，all等谓词来引入。

> 标量（单值）、列（列），表（多行多列）

5. 联合查询：将多个查询结构用nuion或union all合并起来。

> 这些查询结果应该有相同的列数和兼容的数据类型。union会去重，union all会保留重复的行。

### 1.9  事务
事务是一组操作的集合，要么同时成功，要么同时失败。如果执行过程中报错，我们可以回滚事务，把数据恢复到事务开始之前的状态。当有多个事务并发执行时，我们还需要考虑事务隔离的概念。
（start transaction/begin commit rollback）

### 1.10  事务四大特性ACID
(1)	原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 
(2)	一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。（比如转账后钱不能少）
(3)	隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立  环境下运行。
(4)	持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。
其中原子性、一致性和持久性通过重做日志（redo）和回滚日志（undo）来保证。隔离性则通过锁和MVCC来保证。 

### 1.11  并发事务问题
(1)	脏写：一个事务修改了另一个未提交的事务修改过的数据。
(2)	脏读：一个事务读到另外一个事务还没有提交的数据。
(3)	不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。
(4)	幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 "幻影"。

### 1.12  事务隔离级别
默认情况下，InnoDB在 Repeatable Read事务隔离级别运行，解决了脏写、脏读和不可重复读的问题。 然后使用临键锁进行索引扫描，以防止幻读。
RU解决脏写，RC解决脏读、RR解决不可重复读、串行化解决幻读（都向前兼容）
事务的隔离级别越高，数据越安全，但性能越低
（RU:Read Uncommitteed RC:Read Committed RR:Repeatable Read Serializable:串行化）

### 1.13  MySQL体系结构
客户端->连接层->服务层->引擎层->存储层

### 1.14  InnoDB、MyASAM、Memory
(1)	InnoDB是默认存储引擎，支持事务、外键、行级锁。存储分为表空间、段、区（1M）、页（16K）、行。

(2)	MyISAM不支持事务，不支持外键、不支持行锁只支持表锁，访问速度快 ，主要用于高负荷的查询表

(3)	Memory引擎使用hash索引，表数据存储在内存中的，只能作为临时表或缓存使用。与Redis类似，不过

Redis的性能更高所以一般会使用Redis代替。

### 1.15  索引 
索引是帮助MySQL高效获取数据的有序的数据结构。

### 1.16  B树、B-树、B+树、Hash
(1)	B（B-）树也叫多路平衡查找树，例如5阶B树表示每个节点最多有5个子节点，每个节点有4个key5个指针，key的后面会存放数据，指针则指向子节点的位置。子节点不会有和父节点相同的key
(2)	B+树所有的数据都会出现在叶子节点，非叶子节点不包含数据，只起到索引的作用，所以可以用更小的磁盘空间存下索引，减少磁盘io次数。叶子节点形成一个单向链表。MySQL对B+树进一步优化，叶子节点形成的是一个循环双向链表，利于排序和范围查询。B+树更加矮胖，检索时间稳定。
(3)	Hash索引就是采用一定的hash算法，将键值换算成新的hsh值保存在hash表中，这个值可以映射到对应的存储位值上。当出现hash冲突时，MySQL通过链表的方式来解决。hash索引对等比较查询效率很高但是不支持范围查询和排序操作。
(4)	自适应hash索引：如果观察到在特定的条件下hash索引可以提升速度，则自动建立hash索引，称之为自适应hash索引。
(5)	R-tree索引主要用于地理类型的数据
(6)	全文索引（Full-text）主要用于快速匹配文档

### 1.17  红黑树

红黑树是一种自平衡的二叉查找树，通过对节点着色和旋转操作来保持树的平衡，确保最长路径不超过最短路径的两倍。每个节点最多有两个子节点，左子节点小于父节点，右子节点大于父节点。

### 1.18  MySQL为什么使用B+树作为索引结构？

B+树分层的特点可以减少磁盘IO的次数；B+树较为矮胖，查询效率更加稳定；B+树的数据都存放再叶子节点，且通过指针串联起来，因此有很高效的范围查询；B+树的子节点树可以扩充，即使是大批量的数据也能适应。

### 1.17  聚集索引和非聚集索引

聚集索引是索引结构和数据一起存放且只能有一个，默认是主键，而非聚集索引不和数据一起存放且可以有多个。非聚集索引可以查询到聚集索引，当需要回表查询时，再根据聚集索引查找数据。

### 1.18  数据库优化
可以提升数据库性能的方面有：硬件、系统配置、数据库表结构、SQL及索引。成本最低且效果最明显的就是SQL和索引的优化了。SQL优化应该最大化利用索引、减少无效数据的查询、尽可能避免全表扫描

### 1.19  在select之前使用explain或desc 获取 MySQL 如何执行 select 语句的信息（可以检查索引是否命中）
### 1.20  索引失效的情况
(1)	使用不等于（<>或!=）
(2)	使用in和not in，范围查询最好使用between and才不会失效
(3)	在索引列上进行运算操作
(4)	发生类型转换（字符串类型的字段不加引号） 
(5)	头部模糊查询（尾部模糊查询不会）
(6)	 or前后没有同时使用索引都会失效
(7)	联合索引不遵守最左前缀法则（索引左边列要在SQL里出现）
(8)	联合索引中，用>和<，右侧的列索引失效（它本身不失效）。使用>= 或 <= 时，索引不会失效
(9)	联合索引跳过中间列，后边的索引不会被用到
(10)	如果MySQL评估使用全表查询更快，则不使用索引。（is null和is not null 根据此类情况讨论）

### 1.21  最左匹配原则

索引在B+数的节点中存放的顺序跟建立时候的顺序是一样的，在查询时要先匹配最左侧的索引列，然后再依次向右匹配其余索引列。当没有最左侧的索引时，就不能满足这个索引扫描的条件。

### 1.21  索引设计原则 

(1)	针对于数据量较大，且查询比较频繁的表建立索引。 
(2)	针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。 
(3)	尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。 （唯一索引找到后不会继续检索）
(4)	如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。 （用了前缀索引就用不了覆盖索引）
(5)	根据查询情况建立联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。 
(6)	要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
(7)	尽量使用非空约束加默认值。当优化器知道每列是否包含null值时，它可以更好地确定哪个索引最有效地用于查询。

### 1.22  SQL优化
(1)	首先要想查询速度快我们应该建立合适的索引、或者是覆盖索引，然后用SQL提示让MySQL走我们预期的索引。
(2)	在优化之前可以使用show profiles命令查看查询时间都耗费到哪里去了（show profiles;+show profiles for query ID;）
(3)	批量插入可以减少数据库解析次数和连接次数
(4)	主键优化：主键要顺序插入，乱序插入会导致页分裂（后一半数据分到其它页），耗费性能。尽量降低主键的长度选择自增主键，不使用uuid和身份证等自然主键。避免对主键的修改
(5)	order by优化：MySQL两种排序方式： 第一种通过索引顺序直接返回数据的方式效率最高，而另一种则是把数据复制到缓冲区中排序然后再将排好序的数据返回性能低。所以我们应该给经常排序的字段建立合适的索引。尽量使用覆盖索引(order后的字段顺序最好和建立联合索引时的顺序一致，不一致就会filesort） 。如果不可避免的要使用缓冲区排序时，可以适当增大排序缓冲区的大小 (默认256k)。
(6)	group by优化：默认是先排序后分组，依然可以先建立合适的索引，或者在不需要排序的时候设置它。
(7)	limit优化 ：一般采用子查询的形式进行优化。可以理解为在子表先对id排序和分页再和主表联合查询找数据。
例如查询2000000条到2000010条（limit 2000000,10）

```mysql
explain  select  *  from  tb_sku  t  ,  (select  id  from  tb_sku  orde r by  id 
limit  2000000,10)  a  where  t.id  =  a.id; --此步对主表进行筛选
```

(8)	update优化：InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。 回表时就会变为表锁，此时并发开启多个事务时，性能将大大降低。
(9)	count优化 ：MySQL不会自动计数，需要用count（）函数计数，效率：count(字段) < count(主键) < count(1) <count(*)，mysql对count(\*)做了优化，所以尽 量使用 count(\*)。
（没有主键的时候count（1）比count（*）快） 

### 1.23  对大批量数据的优化
（1）分库分表（垂直分记录不完整，水平分记录完整）
（2）读写分离
（3）对大表查询时需带限定范围（比如查询历史记录自动限定在两个月内）

### 1.24  视图的作用：
(1)	简化用户的理解，帮助用户屏蔽表结构的变化
(2)	安全性：可以屏蔽其它字段
### 1.25  不符合视图创建条件的数据不会插入视图但是会插入基表中,怎样做到满足条件才能插入基表中？
使用with casecaded/local check option。caesecade会级联检查多个嵌套视图；local只会检查当前视图

### 1.26  存储过程
可以存储SQL语句，以后可以多次调用，相同的SQL语句不用多次输入。可以接受参数
游标（CURSOR）：用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理
存储函数：有返回值的存储过程，存储函数的参数只能是IN类型的。


### 1.27  触发器（trigger）
触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。现在触发器还只支持行级触发，不支持语句级触发。 

### 1.28  事务的并发读写问题
采用MVCC的方式，读-写操作彼此并不冲突，性能更高。
加锁方式的话，读-写需要排队执行，影响性能

### 1.29  锁
锁是计算机协调多个进程或线程并发访问某一资源的机制。按照对数据的操作类型可以分为共享锁和排他锁也叫读写锁，在InnoDB引擎中，读写锁既可以加在行上也可以加在表上。然后按照锁的粒度可以分为行级锁、页级锁和表级锁，需要注意的是，行锁是基于索引实现的，当索引失效时行锁就会转变为表锁，影响性能。行级锁又可分为行读写锁,间隙锁、临键锁、插入意向锁4种；表级锁也可分为表级读写锁、意向锁、自增锁、元数据锁四种，
### 1.30  行级锁
（1） 行级读写锁，读-读兼容，其他互斥
（2）间隙锁不允许在加锁的记录之前再插入数据，防止出现幻读的情况
（3）临建锁其实就是行锁和间隙锁的组合，既可以锁住当前行，又可以锁住前边的间隙，防止插入。
（4）插入意向锁是指间隙已经被锁住，但是自己还想插入就需要排队等待。
### 1.31  表级锁
（1）标记读写锁，读-读兼容，其他互斥
（2）意向锁也分为意向共享锁和意向排他锁，意向锁主要解决行锁与表锁的冲突，使得表锁不用检查每行数据是否加锁，意向锁之间都不互斥；与普通表锁的关系：读和意向读不互斥，其它都互斥。（例：某行加写锁，表自动加意向排它锁，当其它事务想要来加表锁的时候就不用逐行检查是否有排它锁了）
（3）自增锁主要是在有自增主键的情况下使用，因为每次只能加1，当有不同事务同时添加记录时就需要自增锁去约束
（4）元数据锁是系统自动控制，指的是一张表上有未提交的事务时，不能修改表的结构。
### 1.32  死锁（和操作系统的一样）
(1)	两个或两个以上事务
(2)	每个事务都持有锁并且申请新锁
(3)	锁资源同时只能被同一个资源持有
(4)	事务之间因为持有锁又想获得对方的锁而循环等待
### 1.33  处理死锁
(1)	设置超时后事务自动取消然后回滚
(2)	使用死锁检测进行死锁处理
### 1.34  InnoDB引擎 
存储
每张表都会有一个表空间（table1.ibd），表空间内可分为段， 索引段即为B+树的非叶子节点，数据段就是B+树的叶子节点。段又可分为区，每个区的大小为1M。区又分为页， 默认情况下， InnoDB存储引擎页大小为16K， 即一 个区中一共有64个连续的页。页中的行就是所存放的记录，每行都有两个隐藏字段 
Trx_id：最近修改这条记录的事务的id。 
Roll_pointer：回滚指针，指向在undo日志中这条记录的上一个版本 
Row_Id：隐藏主键，没有主键时将会自动生成此字段
架构-内存
（1）缓冲池（Buffer Pool）：存放经常操作的数据，然后再以一定频率刷新到磁盘，从而减少磁盘IO，提升性能
（2）更改缓冲池（Change Buffer）存放被更改的数据，之后再恢复到缓冲池
（3）自适应哈希索引（Adaptive Hash Index）：用于优化对缓冲池数据的查询，系统自动支持
（4）日志缓冲区（Log Buffer）：保存要写入磁盘的日志
架构-磁盘
（1）双写缓冲区（Double Buffer Files）：刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据
（2）系统表空间（System tablespace）：包含表和索引数据
（3）撤销表空间（Undo tablespace）：存储回滚日志（Undo log）
（4）临时表空间（Temporary tablespace）：存放临时数据
（5）重做日志：用于存放重做日志（Redo log）
（6）File-Per-table tablespaces
（7）通用表空间General tablespaces 

线程
（1）核心线程：调度其它线程；将数据刷新到磁盘
（2）IO线程：处理IO请求
（3）Purge Thread：回收事务执行后的回滚日志
（4）Page Cleaner Threed：协助主线程将脏页刷新到磁盘

### 1.35  日志种类
### 1.35  日志种类
（1）重做日志（redo log）：记录修改信息，异常时用于进行数据恢复
（2）回滚日志（undo log）：记录数据修改之前的信息，用于回滚事务和多版本并发控制（MVCC）
（3）二进制日志（bin log）：记录DDL和DML语句，用于主从复制和灾难时的数据恢复
（4）错误日志：记录错误信息
（5）查询日志：记录客户端所有的操作语句
（6）慢查询日志：可以配置查询时间超过多少秒时就记录它

### 1.36  当前读和快照读
当前读读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。
而简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。 

### 1.37  MVCC
多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，需要依赖于数据库记录中的三个隐式字段、回滚日志（undo log）和读视图（ReadView） 。
### 1.38  主从复制
主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，从库记录到自己的终极日志后重新执行这些操作，从而使得从库和主库的数据保持同步。
优点：（1）主库宕机可以用从库提供服务；
（2）实现读写分离；
（3）可以在从库进行备份
### 1.39  读写分离
把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。 
### 1.40  多主多从
一个主机 Master1 用于处理所有写请求，它的从机 Slave1 和另一台主机 Master2 还有它的从机 Slave2 负责所有读请求。当 Master1 主机宕机后，Master2 主机负责写请求，Master1 、Master2 互为备机。
### 1.41  分库分表
当数据量变得非常大时，只在一个主机上管理这些数据非常吃力，性能跟不上。
垂直分库：把一个数据库内不同的表分到不同的主机上
垂直分表：把一张表上不同的列分到不同的主机上
水平分库：所有数据库的表都一样，表内数据不一样
水平分表：将一个表的数据拆分到多个表中，表结构一样，数据不一样
### 1.42  读视图ReadView
进行快照读时产生的视图

## 2 MySQL基础

>运行mysql服务：net start mysql80   （管理员身份运行cmd）
>
>关闭mysql服务：net stop mysql80
>
>连接MySQL：
>
>（1）客户端 Client连接
>
>（2）执行命令：mysql -h 127.0.0.1 -P 3306 -u root -p
>
>​			   	    mysql -u root -p
>
>本机连接密码：fantastic0918
>
>CentOS7的MySQL连接密码：fantastic0918




### 2.1  MySQL数据库结构
**2.1.1**  数据库（DB）：如database1，dat2；数据库管理系统（DBMS）：如MySQL，Oracle

**2.1.2 MySQL**  数据库  --> 表

数据库 ：school_dmu

表举例

student

| id   | name  | gender | age  | birth_day  | contry |
| ---- | ----- | ------ | ---- | ---------- | ------ |
| 001  | Tom   | 男     | 5    | 2001-02-03 | 美国   |
| 002  | Jerry | 男     | 18   |            | 英国   |
| 003  | Jack  | 男     | 34   |            | 法国   |
| 004  | Lucy  | 女     | 53   |            | 德国   |

exam_score

| id   | student_id | course | score | is_pass |
| ---- | ---------- | ------ | ----- | ------- |
| 1    |            |        |       |         |
| 2    |            |        |       |         |
| 3    |            |        |       |         |
| 4    |            |        |       |         |



### 2.2  MySQL的注释和数据类型
**2.2.1  注释**  
（1）单行注释：--注释内容 或 #注释内容  （MySQL特有）
（2）多行注释：/* 注释内容 */

**2.2.2  常用数据类型**

| 类型        | 所占字节       | 备注                                 |
| ----------- | -------------- | ------------------------------------ |
| tinyint     | 1              |                                      |
| smallint    | 2              |                                      |
| mediumint   | 3              |                                      |
| int         | 4              |                                      |
| float       | 4              |                                      |
| double      | 8              | 整数和浮点数的类型后都可以跟unsigned |
| char(3)     | 定长3字节      | char()的性能比varchar()的高          |
| varchar(10) | 变长最大10字节 |                                      |
| data        | 3              |                                      |
| time        | 3              |                                      |
| datetime    | 8              |                                      |

### 2.3  SQL语句的分类
| 类型 | 代表单词     | 类型 | 作用                                 |
| ---- | ------------ | ---- | ------------------------------------ |
| DDL  | Definition   | 定义 | 定义数据库对象                       |
| DML  | Manipulation | 操作 | 增删改                               |
| DQL  | Query        | 查询 | 查询记录                             |
| DCL  | Control      | 控制 | 创建数据库用户、控制数据库的访问权限 |



### 2.4 DDL：定义 

#### 2.4.1  建表语句

```mysql
create table student（						   
id char(4) Primary key [comment '编号'],	
name varchar(10) [comment '姓名'],
gender char(4) [comment '性别'],
age int comment '年龄',
birth_day date [comment '出生日期'],
）engine = innodb [comment '学生表'];								-- 建表时指定存储引擎


create table exam_score( 
id int auto_increment Primary key comment 'ID唯一标识', 
student_id char(4) comment '学生id' ，
course varchar(10) not null unique comment '课程' , 
score int check (score > 0 && score <= 120) comment '成绩' , 
ispass char(1) default '1' comment '及格',
constraint foreign key student_id references student (id)			-- 设置外键
)comment '成绩表';

create （unique)index idx_id_name on exam_score(id,name) ; 			-- 创建唯一联合索引，id和name都不可以有重复的值

alter table exam_score add constraint foreign_name	foreign	key (student_id) references student(id) ;											-- 给已经建好的表设置外键

alter table emp drop foreign key fk_emp_dept_id;			-- 删除外键

```

#### 2.4.2  常用定义表结构语句

```mysql
show databases;									-- 1.展示系统所有数据库

select database();								-- 2.查询当前处于哪个数据库

create database [if not exists] school_dmu [default charset utf8mb4];  -- 3.创建数据库																-- utf8mb4:每个字符占四个字节

drop database [if exists] school_dmu;         	   -- 3.删除数据库

use school_dmu;								  	 -- 4.转到某数据库

show tables;									 -- 5.查看当前位于哪个数据库

desc  student;									 -- 6.查询某个表的表结构

show create table student;						  -- 7.查询建表语句

alter table student add country varchar(20) comment '昵称';  			-- 9.添加列（字段）

alter table student modify country varchar(10) comment ‘昵称’;		-- 10.修改列的类型	

alter table student change id stu_id varchar(30) commment '编号';   -- 11.修改列的名字和类型

alter table student drop country;	  								-- 12.删除列

alter table student rename to student_form;		     				 -- 13.修改表名

drop table [if exists] student;   								 	-- 14.删除表

truncate table student;		   	   			  					-- 15.删除并重新创建该表
-- (删除表的数据，但是保留表结构、索引和约束等。删除后无法恢复。)
```



### 2.5  DML：操作

```mysql
-- 1.插入操作与批量插入（值的数量完整是不用写列名） 
insert into student(id,name,gender,age,birth_day,country) values (001,'Tom'.'男',5,'2001-02-03','美国');
insert into student values (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;-- 批量插入

update emp set name = '小白' where id = 1 ;			-- 2.修改

delete from employee where gender = '女';			-- 3.删除行，没有条件表示删除本表的所有数据

```



### 2.6  聚合函数

```mysql
select count(*) from emp;						-- 1.统计的不为null的总记录条数

select max(age) from emp;						-- 2.返回最大的age值

select min(age) from emp;						-- 3.返回小的age值

select avg(age) from emp;						-- 4.返回age的平均值

select sum(age) from emp where contry = '美国';	-- 5.返回美国学生的年龄的总和
```


### 2.7  DQL：查询

```mysql
select [distinct] id,name from student where dender = '男' group by country,gender [having 分组后过滤条件] oder by id [asc,age desc], limit 0,10\G;

-- 1.在select后加distinct可去除查询到的重复记录

-- 2. 比较符：>,>=,<,<=,=,<>或!=,between..and..包含边界,in(1,4)符合1或4，like '_%' _占一位，%占多位,is null；逻辑：and-&&，or-||，not-！

-- 3.分组查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。按多段分组记录条数就是分组内所有种类的笛卡尔乘积.

-- 4.order by（排序查询）：asc（升序），desc（降序）。

-- 5.limit（分页查询）：索引从0开始，第二个参数是每页展示记录的条数

-- 6.在结尾加上/G表示查询到的信息按行显示
```


### 2.8  DCL
**2.8.1  管理用户**

```mysql
select * from mysql.user;								-- 1.查询有多少用户

create user  '用户名'@'主机名' identified by '密码';		-- 2.创建用户
 
alter user  '用户名'@'主机名'  identified with  mysql_native_password  by '新密码' ;-- 4.修改用户密码

drop  user  '用户名'@'主机名' ;							-- 3.删除用户
```

**2.8.2  权限控制**
MySQL中定义了很多种权限，但是常用的就以下几种：

| 权限                | 说明               |
| ------------------- | ------------------ |
| all, all privileges | 所有权限           |
| select              | 查询数据           |
| insert              | 插入数据           |
| update              | 修改数据           |
| delete              | 删除数据           |
| alter               | 修改表             |
| drop                | 删除数据库/表/视图 |
| create              | 创建数据库/表      |

```mysql
show grants for  '用户名'@'主机名' ;						 -- 1.查询权限

grant 权限列表 on 数据库名.表名 TO '用户名'@'主机名';		  -- 2.授予权限

revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';	   -- 3.撤销权限
```

### 2.9  字符串函数

MySQL中内置了很多字符串函数，常用的几个如下：

| 函数                     | 功能                                                         |
| ------------------------ | ------------------------------------------------------------ |
| concat(S1,S2,...Sn)      | 字符串拼接，将S1，S2，... Sn拼接成一个字符串                 |
| lower(Str)               | 将字符串str全部转为小写                                      |
| upper(str)               | 将字符串str全部转为大写                                      |
| lpad(str,n,pad)          | 左填充，用字符串pad对str的左边进行填充，使str达到n个字符串长度 |
| rpad(str,n,pad)          | 右填充，用字符串pad对str的右边进行填充，使str达到n个字符串长度 |
| trim(str)                | 去掉字符串头部和尾部的空格                                   |
| substring(str,start,len) | 返回从字符串str从start位置起的len个长度的字符串。substring：起始下标从1开始 |

```mysql
update student set id = lpad(workno, 5, '0');					-- 左填充
```





### 2.10  数值函数
常见的数值函数如下：
| 函数       | 功能                               |
| ---------- | ---------------------------------- |
| cell(x)    | 向上取整                           |
| floor(x)   | 向下取整                           |
| mod(x,y)   | 返回x/y的模                        |
| rand()     | 返回0~1内的随机数                  |
| round(x,y) | 求参数x的四舍五入的值，保留y位小数 |

```mysql
	select lpad(round(rand()*1000000 , 0), 6, '0');					-- 返回6位随机数
```

### 2.11  日期函数
常见的日期函数如下：

| 函数                                                                                            | 功能                                  |
| ----------------------------------------------------------------------------------------------- | ------------------------------------- |
| curdate()                                                                                       | 返回当前日期                          |
| curtime()                                                                                       | 返回当前时间                          |
| now()                                                                                           | 返回当前日期和时间                    |
| year(date)                                                                                      | 获取指定date的年份,当前年:year(now()) |
| month(date)                                                                                     | 获取指定date的月份                    |
| day(date)                                                                                       | 获取指定date的日期                    |
| date_add(date, interval expr  year/month/day) |返回一个日期/时间值加上一个时间间隔expr后的时间值|
| datediff(date1,date2) |返回结束时间date1 和 开始时间date2之间的天数,返回date1-date2|

```mysql
-- 返回入职天数
select name, datediff(curdate(), entrydate) as 'entrydays' from emp order by entrydays desc;
```





### 2.12 流程函数
流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。
| 函数                                                            | 功能                                                      |
| --------------------------------------------------------------- | --------------------------------------------------------- |
| if(value , t , f)                                               | 如果value为true，则返回t，否则返回f                       |
| ifnull(value1 , value2)                                         | 如果value1不为空，返回value1，否则返回value2              |
| case when[ val1 ] then [res1] ...else [ default ] end           | 如果val1为true，返回res1，... 否则返回default默认值       |
| case [ expr ] when [ val1 ] then[res1] ... else [ default ] end | 如果expr的值等于val1，返回res1，... 否则返回default默认值 |

```mysql
select id,name,
(case when math >= 85 then '优秀' when math >=60 then '及格' else '不及格' end ) '数学',
(case when english >= 85 then '优秀' when english >=60 then '及格' else '不及格' end ) '英语',
(case when chinese >= 85 then '优秀' when chinese >=60 then '及格' else '不及格'end ) '语文'
from score;
```

### 2.13  约束-作用于字段上-限制作用
目的：保证数据库中数据的正确、有效性和完整性。

| 约束                     | 描述                                                     | 关键字      |
| ------------------------ | -------------------------------------------------------- | ----------- |
| 非空约束                 | 限制该字段的数据不能为null                               | not null    |
| 唯一约束                 | 保证该字段的所有数据都是唯一、不重复的                   | UNIQUE      |
| 主键约束                 | 主键是一行数据的唯一标识，要求非空且唯一                 | primary key |
| 默认约束                 | 保存数据时，如果未指定该字段的值，则采用默认值           | default     |
| 检查约束(8.0.16版本之后) | 保证字段值满足某一个条件                                 | check       |
| 外键约束                 | 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 | foreign key |
### 2.14  删除更新行为（5种）

|      | 行为        | 作用                   |
| ---- | ----------- | ---------------------- |
| 1    | no action   | 有外键不允许删除       |
| 3    | cascade     | 级联，父表删子表也删   |
| 4    | set null    | 父表删，子表变为null   |
| 5    | set default | 父表删，子表变为默认值 |

### 2.15  建有关联表的方式

| 关联方式 | 实现方式                                                     |
| -------- | ------------------------------------------------------------ |
| 一对多   | 在多的一方建立外键，指向一的一方的主键                       |
| 多对多   | 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键   |
| 一对一   | 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE) |

### 2.16 内连接

* <u>from student,exam_score</u>形成的虚表行数是两表笛卡尔乘积，列数是两表列数之和。
* where 是筛选掉不符合条件的行

```mysql
-- 1.隐式内连接	
select * from student,exam_score where student.id = exam_score.student_id;
--  2.显式内连接(需要有连接体条件)
select * from student [inner] join exam_score on student.id = exam_score.student_id ; 
```

### 2.17  外连接

* 形成的表的行数和左表一样，列数是两表列数之和。(外连接不是笛卡尔乘积)
* 如果左表有的记录没有在右表找到对应的数据，则连接后属于右表的属性值为NULL

```mysql
-- 1.左外连接（连接表1和表2，返回左表1的所有数据，加上对应的右表的数据，没有时为空。）
select * from student left [outer] join exam_score on student.id = exam_score.student_id;

-- 2.右外连接（连接表1和表2，返回右表2的所有数据，加上对应的左表的数据，没有时为空。）
select * from student right [outer] join exam_score on student.id = exam_score.student_id;
```

### 2.18  自连接

```mysql
-- 自连接可以是内连接也可以是外连接
-- 自连接必须要起别名，要不然两表会混淆
select * from	student	stu1 join student stu2	on 条 件 ... ;
```

### 2.19  联合查询

```mysql
select 字段列表	from	表 A ...
union [ all ]							-- union去重，union all不去重
3 select 字段列表  from	表B	;
```

### 2.20  子查询

```mysql
-- 1.SQL语句中嵌套select语句，称为嵌套查询，又称子查询。子查询外部的语句可以是insert / update / delete/ select 的任何一个。但是括号里面只能是select语句.
select * from	t1	WHERE column1 = ( select column1 from t2 );

-- 2.标量子查询的子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。  常用的操作符：=	<>	>	>=	<	<=
select * from emp where dept_id = (select id from dept where name = '销售部');

-- 3.列子查询d额子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL
select * from emp where dept_id in (select id from dept where name = '销售部' or name = '市场部');

-- 4.行子查询的子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。常用的操作符：= 、<> 、IN 、NOT IN
select * from emp where (salary,managerid) = (select salary, managerid from emp where name = '张无忌');

-- 5.表子查询的子查询返回的结果是多行多列，这种子查询称为表子查询。常用的操作符：IN
select e.*, d.* from (select * from emp where entrydate > '2006-01-01') e left join dept d on e.dept_id = d.id ;
```

### 2.21  其他查询方式的SQL

查询某个字段是否有重复值

```c#
string sql = string.Format(@" select p.ITEM_NUMBER,COUNT(*) from innovator.HS_PRODUCT_REL_PART hprp left join innovator.PART p on  hprp.RELATED_ID = p.id where SOURCE_ID = '{0}' group by RELATED_ID,p.ITEM_NUMBER having COUNT(*) > 1 ",id);
```



## 3  MySQL进阶

### 3.1  事务

#### 3.1.1  事务的概念

事务是一组操作的集合，要么同时成功，要么同时失败。如果执行过程中报错，我们可以回滚事务，把数据恢复到事务开始之前的状态。当有多个事务并发执行时，我们还需要考虑事务隔离的概念。
（用start transaction或者begin开启事务、commit提交事务、rollback在事务出错时回滚）

>  默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。我们需先设置成事务手动提交

```mysql
SELECT @@autocommit ;							-- 1.查看事务提交方式
SET	@@autocommit = 0 ;							-- 2.设置事务提交方式
```

#### 3.1.2  事务代码例子

```mysql
-- 把张三的1000块转给李四
start transaction 											-- 也可以使用begin
select * from account where name = '张三'; 
update account set money = money - 1000 where name = '张三'; 
update account set money = money + 1000 where name = '李四';
commit;														-- 出错时使用rollback
```

#### 3.1.3  事务的四大特性-ACID

| 特性   | 来源单词    | 含义                                                         |
| ------ | ----------- | ------------------------------------------------------------ |
| 原子性 | Atomicity   | 事务是不可分割的最小操作单元，要么全部成功，要么全部失败     |
| 一致性 | Consistency | 事务完成时，必须使所有的数据都保持一致状态                   |
| 隔离性 | Isolationl  | 数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立  环境下运行 |
| 持久性 | Durability  | 事务一旦提交或回滚，它对数据库中的数据的改变就是永久的       |

#### 3.1.4  并发事务问题

| 问题       | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏写       | 一个事务修改了另一个未提交的事务修改过的数据                 |
| 赃读       | 一个事务读到另外一个事务还没有提交的数据                     |
| 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读 |
| 幻读       | 个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 "幻影" |

#### 3.1.5  事务的隔离级别

默认情况下，InnoDB在 Repeatable Read（RR）事务隔离级别运行，解决了脏写、脏读和不可重复读的问题。 然后使用临键锁（next-key）进行索引扫描，以防止幻读。

| **隔离级别**     | 脏写 | **脏读** | **不可重复读** | **幻读** |
| ---------------- | ---- | -------- | -------------- | -------- |
| Read uncommitted | √    | √        | √              | √        |
| Read committed   | √    | ×        | √              | √        |
| Repeatable Read  | √    | ×        | ×              | √        |
| Serializable     | √    | ×        | ×              | ×        |

```mysql
-- 1.查看事务隔离级别
SELECT @@TRANSACTION_ISOLATION;

-- 2.设置事务隔离级别
SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }
```

> 注意：事务隔离级别越高，数据越安全，但是性能越低。

### 3.2  存储引擎

```mysql
-- 查询当前数据库支持的存储引擎
show engines; 
```

### 3.3  InnoDB

特点：支持事务、外键、行级锁

表空间

每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间

段

数据段就是B+树的叶子节点， 索引段即为B+树的 非叶子节点。

区

每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一 

个区中一共有64个连续的页。

页

页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为

行

InnoDB 存储引擎数据是按行进行存放的

在行中，默认有两个隐藏字段： 

Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。 

Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 

隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。 

### 3.4  MyISAM

特点：不支持事务，不支持外键、支持表锁，不支持行锁 、访问速度快 

### 3.5  Memory

介绍 ：Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。 

特点：内存存放 、hash索引（默认）

### 3.6  索引

索引是帮助MySQL高效获取数据的有序的数据结构。

> 三个存储引擎都支持B+树索引，只有Memory支持hash索引
>
> Hash索引只能用于对等比较，不能范围查询，且无法排序，但是查询效率高

### 3.7  查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次

``` mysql
show global status like 'Com_______'; 				-- 7个'_'
```

### 3.8  show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。

```mysql
-- 查看当前MySQL是否支持：
SELECT @@have_profiling ;

-- 开启：
SET profiling = 1; 

-- 查看每一条SQL的耗时基本情况 
show profiles; 

-- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;-- （query_id是上一条语句查到的id）; 

```

​	

### 3.9  在select之前使用explain或desc 获取 MySQL 如何执行 SELECT 语句的信息

​	（可以检查索引是否命中）

### 3.10  覆盖索引

覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。 （尽量使用覆盖索引，减少select *，避免回表查询）

> 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。创建联合索引，在查询的时候走覆盖索引，避免回表查询，可以提高查询性能。

#### 3.10.1  最左前缀法则

创建联合索引时要注意左边的索引应该考虑到在查询时尽可能使用到（最左前缀法则）最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。

#### 3.11  前缀索引

当字段类型为字符串时，有时候需要索引很长的字符串，这会让索引变得很大，此时可以只将字符串的一部分前缀，建立索引

```mysql
-- 创建前缀索引
reate index idx_email_5 on tb_user(email(5)); 

-- 查看前缀索引的选择性
select count(distinct substring(email,1,5)) / count(*) from tb_user ;
```



使用了前缀索引必须要回表才能拿到需要的数据，即使是只查找索引本身所在的字段。所以，用了前缀索引，就用不了覆盖索引了。

11、

#### 3.12  SQL提示

SQL提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 

```mysql
select * from emp use index(idx_name) where name=’tom’;ignore index / force index
```

#### 3.13  索引失效

(1) 联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。当范围查询使用>= 或 <= 时，索引不会失效

(2) 不要在索引列上进行运算操作，否则索引将失效。 

(3) 字符串类型字段使用时，不加引号，索引将失效。 

(4) 如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。 

(5) 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。 

(6) 如果MySQL评估使用索引比全表更慢，则不使用索引。

#### 3.14  索引设计原则 

(1) 针对于数据量较大，且查询比较频繁的表建立索引。 

(2) 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。 

(3) 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。 

(4) 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。 

(5) 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。 

(6) 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。

(7) 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。

#### 3.15  SQL优化-插入数据

#####  3.15.1  插入优化

1. load比批量插入数据块，批量插入数据块比多次插入数据快。

   ```mysql
   -- 大批量插入数据应优先使用load：
   -- 客户端连接服务端时，加上参数 -–local-infile 

   mysql –-local-infile -u root -p 

   -- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关

   select  @@local_infile;

   set global local_infile = 1; 

   -- 执行load指令将准备好的数据，加载到表结构中 

   -- 先在mysql中创建tb_user表

   load data local infile '/root/load_user_100w_sort.sql' into table tb_user 
   fields terminated by ',' lines terminated by '\n' ; 
   ```

2. 手动事务控制插入也比多次插入快

   ```mysql
   start transaction; (begin) 
   insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry'); 
   insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry'); 
   insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry'); 
   commit;
   ```

   ​

##### 3.15.2  主键优化

1. 主键顺序插入的性能是要高于乱序插入：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，乱序插入会导致“页分裂”比较耗费性能

> 删除时会导致页合并优化空间，合并页的阈值，可以自己设置，在创建表或者创建索引时指定。当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），innoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。 

2. 满足业务需求的情况下，尽量降低主键的长度。 
3. 尽量选择使用auto_increment自增主键，不要使用UUID做主键或者是其他自然主键，如身份证号。 
4. 业务操作时，应避免对主键的修改。 

##### 3.15.3  order by优化

MySQL的排序，有两种方式： 

Using filesort：在排序缓冲区sort buffer中完成排序操作

Using index：通过有序索引顺序扫描直接返回有序数据，操作效率高

1. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。	(order后的字段顺序最好和建立联合索引时的顺序一致，不一致就会filesort） 

2. 尽量使用覆盖索引。 （select内容都在索引中）

3. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则。

   ```mysql
   create index idx_user_age_phone_ad on tb_user(age asc ,phone desc); 
   ```

4. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区的大小 sort_buffer_size(默认256k)。

##### 3.15.4  group by优化

（1）在分组操作时，可以通过索引来提高效率。 

（2）分组操作时，索引的使用也是满足最左前缀法则的。

##### 3.15.5  limit优化 

例如查询2000000条到2000010条（limit 2000000,10）

优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。

```mysql
explain  select  *  from  tb_sku  t  ,  (select  id  from  tb_sku  orde r by  id 

limit  2000000,10)  a  where  t.id  =  a.id; 

```

##### 3.15.6  count优化 

如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数 据库进行,但是如果是带条件的count又比较麻烦了)。

按照效率排序的话，count(字段) < count(主键 id) < count(1) ≈ count(*)，所以尽 量使用 count(*)。 

##### 3.15.7  update优化 

InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁 升级为表锁 。 （回表时就会变为表锁，此时并发开启多个事务时，性能将大大降低）

#### 3.11  视图 

是一种虚拟存在的表(select查询时的表)。视图中的数据并不在数据库中实际存在

```mysql
-- 创建
create or replace view stu_v_1 as select id,name from student where id <= 10 with cascade check option; 

-- 查询

SHOW CREATE VIEW 视图名称; 							-- 查看创建视图语句

SELECT * FROM 视图名称 ...... ; 					-- 查看视图数据

-- 修改 

create/alter [or replace] view 视图名称[(列名列表)] as select语句 [ with 
[ cascade | local ] check option ] 

-- 删除 
drop view [IF EXISTS] 视图名称 [,视图名称] ...

```



**mysqlL允许基于另一个视图创建视图**

​	也可以通过视图来插入、更新基表数据

​	不符合视图创建条件的数据不会插入视图但是会插入基表中

​	怎样做到满足条件才能插入基表中？

​	答案是使用with casecaded/local check option

**casecaded 级联**

比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图 创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。 

**local 本地**

比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创 建时未指定检查选项。 则在执行检查时，只会检查v2，不会检查v2的关联视图v1。

**视图的更新**

要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一 项，则该视图不可更新： 

A. 聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等） 

B. DISTINCT 

C. GROUP BY 

D. HAVING 

E. UNION 或者 UNION ALL

**视图作用 **

(1) 简单（不必每次操作都指定全部条件）

(2) 安全（通过视图只能操作所能看到的数据）

(3) 数据独立（屏蔽真实表结构变化带来的影响）

 

#### 3.12  存储过程

```mysql
-- 1.定义存储过程
create procedure pro1( )
begin
select * from tab1;
end;

-- 2.调用该存储过程
call pro1( );	

-- 3.查看存储过程及状态信息：
select * from information_schema.ROUTINEES where ROUTINE_SCHEMA = '数据库名';

-- 4.查看定义信息：
show create procedure pro1;

-- 5.删除
drop procedure if exists pro1;

-- 6.在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的 结束符。 
delimiter $$
begin pro...
select....;(未结束)
end$$
delimiter ;
```



#### 3.13  变量

在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。

```mysql
-- 查看
show session/global variables like ‘...’;
select @@系统变量名;（查看单个）

-- 设置
set session/global   系统变量名 = 值 ;

-- 注意：
-- 如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。 
-- mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在/etc/my.cnf 中配置。 
-- 全局变量(GLOBAL): 全局变量针对于所有的会话。 
-- 会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。

-- 用户定义变量 
set @var_name ：= expr [, @var_name = expr] ... ;
select count(*) into 变量名 from tab1;（查询结果作为变量的值）

-- 局部变量
-- 根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。范围是在其内声明的BEGIN ... END块。
create procedure pro2( )
begin
declare var1 int default 0;
select count(*) into var1 from student;
select var1;
end;

```





#### 3.14  参数

```mysql
-- 类型：in（输入）、out（输出）、inout（既可以作为输入也可以作为输出）
create procedure pro3(in score int, out result varchar(10))
begin
if score>85 then
set result:=’优秀’;
elseif score>60 then
set resoult:=’及格’;
else
set resoult:=’不及格’;
end if;
end;

call pro3(65,@resoult);
select @resoult;
```

36、case(看例题）

37、while(看例题）

38、repeat(看例题）

39、loop(看例题）

40、游标 

游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进 行循环的处理。使用：open  fetch  close

41、条件处理程序 

条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。

#### 3.15  存储函数 

存储函数（function）是有返回值的存储过程，存储函数的参数只能是IN类型的。

#### 3.16  触发器

触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。现在触发器还 只支持行级触发，只支持行级触发，不支持语句级触发。 

```mysql
-- c=创建触发器
create trigger trigger_name 
before/after  inser/update/delete 
on tbl_name for each row -- 行级触发器 
begin 
insert into 日志表 						//记录修改内容
end; 

-- 查看触发器：
show triggers;

-- 删除触发器：
drop trigger schema_name.trigger_name;
```



#### 3.17  锁

锁是计算机协调多个进程或线程并发访问某一资源的机制。

#### 3.18  全局锁

对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。

**数据备份**

``` mysql
flush tables with read lock ; 							-- 加全局锁  
mysqldump -uroot –p1234 itcast > itcast.sql 			-- 数据备份  
unlock tables ; 										-- 释放锁  
```

> 在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致 性数据备份

#### 3.19  表级锁（表锁、元数据锁、意向锁）

##### 表锁

表锁分为两类

* 表共享读锁（read lock） 
* 表独占写锁（write lock）

``` mysql
-- 加锁
lock tables 表名...  read/write。 

-- 释放锁
unlock tables; -- 或客户端断开连接 时自动释放
```

结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞 其他客户端的写但是不阻塞自身的读和写。 

##### 元数据锁（MDL）

元数据锁的是表结构锁，**也就是说，一张表涉及到未提交的事务时，是不能够修改这张表的表结构的**。它的加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。**避了免查询操作与定义操作的冲突，保证读写的正确性。**

当执行select、insert、update、delete等语句时，添加的是元数据共享锁（shared_read /shared_write），之间是兼容的。

而alter语句添加的exclusive锁与元数据读写锁都是互斥的

##### 意向锁

为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。

意向共享锁(IS): 由语句select ... lock in share mode添加 。 与 表锁共享锁 

(read)兼容，与表锁排他锁(write)互斥。 

意向排他锁(IX): 由insert、update、delete、select...for update添加 。与表锁共 

享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。 

一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。

```mysql
-- 查看意向锁及行锁的加锁情况：
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
```

#### 3.20  行级锁（基于索引）（行锁，间隙锁，临键锁）

##### 行锁

共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。 

排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。（S和S兼容，X和S、X都互斥）

没有索引，行锁就会升级为表锁

##### 间隙锁&临键锁

索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。

索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。

索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止。 

间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。



 

#### 3.21  架构 

MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。

内存结构：

缓冲池：经常使用到的数据

 

更改缓冲区：在执行DML语句时，如果这些数据Page 

没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 

中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。

 

自适应hash索引：如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。（自动）

 

日志缓冲区：用来保存要写入到磁盘中的log日志数据，定期刷新到磁盘中。

 

磁盘结构：

 

#### 3.22 后台线程

在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、Page Cleaner Thread。

#### 3.23  事务原理 

原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 

而持久性是通过数据库的锁，加上MVCC来保证的。

 

redo log：重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。 

undo log ：回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) 。

 

 

#### 3.24  MVCC

(1) 当前读

读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select ... lock in share mode(共享锁)，select ... 

for update、update、insert、delete(排他锁)都是一种当前读。

(2) 快照读

简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据， 

不加锁，是非阻塞读。 

(3) MVCC

多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，需要依赖于数据库记录中的三个隐式字段、undo log日志、readView（读视图）是 快照读 。

 

#### 3.25  MySQL管理

(1) mysql

(2) mysqladmin

(3) mysqlbinlog

(4) mysqlshow（查找）

(5) mysqldump（备份）

mysqldump -uroot -p1234 db01 > db01.sql

(6) mysqlimport/source

source /root/xxxxx.sql

 

 

运维篇

#### 3.26  错误日志	/var/log/mysql.log

记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。/var/log/mysql.log

show variables like '%log_error%';

> MySQL宕机时可以查看错误日志恢复数据。也可以使用备份恢复数据。

#### 3.27  二进制日志

二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但 

不包括数据查询（SELECT、SHOW）语句。 

作用：①. 灾难时的数据恢复；②. MySQL的主从复制。在MySQL8版本中，默认二进制日志是开启着 

的，涉及到的参数如下： 

show variables like '%log_bin%'; 

查看：mysqlbinlog [ 参数选项 ] logfilename 

#### 3.28  查询日志 	/var/lib/mysql/mysql_query.log 

查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。

#### 3.29  慢查询日志		





1、配置/etc/my.cnf添加以下两行：开启MySQL慢日志查询：

slow_query_log=1 

 

​		设置慢日志的时间为2秒，SQL语句执行时间超过2秒，则记录慢查询日志 

long_query_time=2 

​	慢日志保存位置：/var/lib/mysql/localhost-slow.log (用 tail -f 跟踪）









慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 

min_examined_row_limit 的所有的SQL语句的日志，默认未开启。long_query_time 默认为 

10 秒，最小为 0， 精度可以到微秒

#### 3.30  主从复制

主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这 

些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。

过程：

主库在事务提交时，记录binlog->从库读取写入自己的relay Log->从库重做中继日志中的事件。 

搭建：

配置my.cnf

#### 3.31  分库分表

当数据量变得非常大时，只在一个主机上管理这些数据非常吃力，性能跟不上。

垂直分库：把不同的表分到不同的主机上

垂直分表：把一张表上不同的列分到不同的主机上

水平分库：所有数据库的表都一样，表内数据不一样

水平分表：将一个表的数据拆分到多个表中，表结构一样，数据不一样

66、实现技术

(1) shardingJDBC：自行编码配置，只支持java，性能高

(2) MyCat：智能中间件，多种语言，性能稍低

67、MyCat分片规则

(1) 范围分片（如id1-500,501-1000）

(2) 取模分片 （如id%3的3个不同的值分到不同的表）

(3) 一致性hash分片

(4) 枚举分片 （如status为0,1,2）

(5) 应用指定算法 （去字符串子串）

(6) 固定分片hash算法 （类似十进制求模运算）

(7) 字符串hash解析算法 （截取字符串中的指定位置的子字符串, 进行hash算法， 算出分片。

(8) 按天分片算法

(9) 自然月分片

68、MyCat原理

在MyCat中，当执行一条SQL语句时，MyCat需要进行SQL解析、分片分析、路由分析、读写分离分析 

等操作，最终经过一系列的分析决定将当前的SQL语句到底路由到那几个(或哪一个)节点数据库，数据 

库将数据执行完毕后，如果有返回的结果，则将结果返回给MyCat，最终还需要在MyCat中进行结果合 

并、聚合处理、排序处理、分页处理等操作，最终再将结果返回给客户端。 

#### 3.32  读写分离

把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。 

#### 3.33  双主双从

一个主机 Master1 用于处理所有写请求，它的从机 Slave1 和另一台主机 Master2 还有它的从 

机 Slave2 负责所有读请求。当 Master1 主机宕机后，Master2 主机负责写请求，Master1 、 

Master2 互为备机。

 

B树和B+树的区别

https://blog.csdn.net/FeiChangWuRao/article/details/124311192?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167115643016782395342498%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167115643016782395342498&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-124311192-null-null.142^v68^control,201^v4^add_ask,213^v2^t3_control2&utm_term=B%E6%A0%91%E5%92%8CB%2B%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB&spm=1018.2226.3001.4187

#### 3.34  如何防止SQL注入



# SQL Server

## 1  SQL Server面试题

### 1.1  SQL Server和MySQL的区别

* SQL Server只有一个Sybase存储引擎。
* MySQL有一些自己的扩展语法如`limit`、`replace`、`insert ignore`等，这些在`SQL Server`中不支持。
* SQL Server在Windows上性能更高而MySQL在Linux系统上性能更高。
* SQL Server在大型系统上的表现更好，而MySQL在中小型系统上的表现会更好。
* SQL Server和MySQL都有自己的安全机制，但是SQL Server的更加成熟和完善，MySQL依赖第三方工具实现更高级的安全功能。
* SQL Server收费，MySQL是开源的

## 2  SQL Server基础

## 3  SQL Server进阶

### 存储过程

存储过程是一个预先编译好的SQL语句，使用它可以达到代码的复用和优化的效果。

> 减少了传递复杂SQL语句的开销，不用每次查询都进行编译。

```sql
create procedure proName-- 创建存储过程的语句，可以用proc代替procedure，proName是存储过程的名字
@id varchar(50)			-- @id是需要传入的参数，可以没有
as
begin					-- as begin 表示存储过程的开始
	select name,age from innovator.users where id = @id 
end

execute proName @id = "246810"			-- 调用存储过程，@id可以省略，按顺序输入参数即可
```

