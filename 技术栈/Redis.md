# Redis6

> 运行：在安装目录：/usr/local/bin下输入：redis-server /etc/redis.conf

## 1  Redis mianshiti
### 1.1  什么是Redis？它主要用来什么的？
Redis是一个基于内存所以读写速度很快，并且可以将数据持久化的非关系数据库，它既不遵循SQL标准也不支持ACID。Redis可以用来做缓存，分布式锁、消息队列、计数器等等。Redis还适用于对数据高并发的读写，海量数据的读写，对数据高可扩展性的读写等（但不适用于对大数据的存储）。

> Redis和MySQL等关系型数据库的区别：
>
> * 关系型数据库主要是以表格来存储数据的，多个表之间可以用外键等进行关联，而非关系型数据库采用键值对，集合，列表等形式存储数据，类型多样。
> * 关系型数据库适合用来处理复杂的事务关系；非关系数据库更适合用来对数据进行处理，比如我们选择Redis作为缓存。

### 1.2  Redis是怎么用来优化的
### 1.3  为什么Redis采用单线程？（单线程+IO多路复用）
因为Redis是基于内存操作的，CPU不是Redis的瓶颈，当所有的数据都在内存中使用单线程去操作速度已经足够快了，当我们换成多线程时，线程上下文的切换会浪费CPU资源，而且使用多线程是存在并发安全的，当我们使用各种锁去控制的话又会导致性能的消耗。所以采用单线程，多进程集群的方案。
但是由于现在业务非常庞大的原因，Redis6引入多线程（但默认关闭需手动配置），可以充分利用多核CPU，多个线程任务分担Redis同步IO读写负荷，由主线程来管理IO线程的读写，所以不需要担心并发安全问题
### 1.4  字符串String
字符串的底层数据结构为简单动态字符串SDS，它包含一个字符数组buf，以及这个数组的长度len和剩余空间free。我们可以直接通过len来获取长度，避免对字符串的遍历，也可以通过free判断添加数据时是否需要重新分配空间，避免了溢出的情况。
二进制安全：buf以二进制形式存储，所以任何可以转化为二进制的都可以存储
扩容：当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。字符串最大长度为512M。
### 1.5  列表List
List的底层数据结构为快速链表，当元素比较少时还只是一个连续分配的压缩链表只存放数据不存放指针，当元素变多后，将多个压缩链表作为节点使用双向链表的方式连接起来就形成了一个快速链表
### 1.6  哈希Hash
Hash的底层数据结构为压缩链表或者Hashtable；当所有元素的key和value的大小都不超过64字节且不超过512个元素时使用压缩链表，否则使用Hashtable；
### 1.7  集合Set
Set的底层是一个自动去重的整数集合intset或者哈希表hashtable；全部是整数且不超过512个是使用intset否则使用hashtable，所有的value都指向同一个内部值；
### 1.8  有序集合Zset

> Zset也会自动去重，但Score的值可以重复。

当Zset中存储的元素都小于64字节且不超过128个时使用压缩链表从小到大存储，否则同时使用hash表和跳跃表存储，hash表实现了快速查找功能而跳跃表则实现了范围查找和排序功能

> 这个底层的hashtable的时间复杂度是什么？

### 跳跃表的原理

### 1.9  三种特殊数据类型
Geo：用于存储地理位置信息。
HyperLogLog：用来做基数统计算法的数据结构，如统计网站的UV。
Bitmaps ：它的底层是基于字符串类型实现的，可以看成是一个以比特位为单位的数组。用这些比特位来映射其它元素的状态。
### 1.10  举例各个类型的应用场景
String：访问量统计，buf是二进制数组，访问时可加1
List：两端存放，可用于存放消息等比如新闻。或者和时间有关的排序
Hash：存储用户属性等，比如一个用户名对应这他的一些个人信息
Set：集合的操作，比如“共同好友”和“猜你喜欢”等交集功能
Zset：排行榜 
### 1.11  事务
Redis的事务本质上是一次性地执行一组命令，由multi开启，将命令入队后输入exec执行事务，它没有隔离级别的概念也不保证原子性。入队时有错误命令则全都不执行。执行后出现错误命令其它命令正常执行。可以使用discard取消事务；也可以使用watch在开启事务之前监测元素，当在命令队列中发现对watch监测元素有改动时则这个事务不会执行（类似于乐观锁）。

> 悲观锁：顾名思义就是很悲观，认为别人可能会修改我获取的数据，所以每次获取数据的时候都会上锁。
>
> 乐观锁：顾名思义就是很乐悲观，认为别人可能不会会修改我获取的数据，只是在获取数据的时候记录版本号，在修改数据之后要提交时检查版本号，如果版本号不变则成功提交修改，否则放弃本次修改并重新获取数据和版本号，直到成功提交修改。



### 1.12  RDB持久化（Redis Database）

> RDB是Redis的默认持久化方式。

RDB是将内存中的数据以快照的形式写入磁盘，有手动和自动触发两种方式，手动触发又分为save和bgsave。save会由主线程进行持久化，性能较低；bgsave会先用fork创建一个子线程，主线程继续进行客户端的交互，由这个子线程采用写时复制技术将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换磁盘中上次持久化好的文件。 整个过程中，主线程是不进行任何IO操作的，这就确保了极高的性能。自动触发是由设置触发bgsave的条件实现的，比如一秒内多少个key发生改变就自动触发bgsave持久化。 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。

> 使用bgsave的时，持久化的过程中依然可以对Redis中的数据进行读写。

### 1.13  AOF持久化
AOF是以日志的形式来记录每个写操作，redis 重启的话就根据日志文件的内容将写指令从前到后执行一遍以完成数据的恢复工作。有三种持久化的策略，每条写操作追加一次（always）、每秒一次（everysec）或者交给操作系统决定（no）。当AOF文件过大时Redis还会对AOF文件进行压缩重写（重写方式与RDB一样）。AOF记录的数据比较精确不容易丢失但是文件比较大，恢复备份的过程也比较慢
### 1.14  应该选择哪个持久化
如果对数据完整性有很高的要求，推荐两个都启用；对数据完整性要求不高可用使用RDB；不建议单独使用AOF，因为可能出现bug；如果只是作为缓存使用可以都不用。
### 1.15  什么是写时复制技术
如果有多个调用者同时请求相同资源，他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者。
### 1.16  主从复制的原理
从服务器连接到主服务器后会发送一个请求命令，主服务器接到命令后会进行RDB持久化，然后将RDB文件发送给从服务器（全量复制）。之后每次主服务器进行写操作都会主动和从服务器进行同步（增量复制）。
### 1.17  一主二仆
从服务器宕机，如果是在配置文件中配置主从模式则重启后仍是从服务器。主服务器宕机从服务器不会上位，仍会等着主服务器重启。
### 1.18  薪火相传
从服务器之下还有它自己的从服务器，主服务器或者中间的从服务器宕机了后面的从服务器都无法备份
### 1.19  反客为主
当主服务器宕机后，后面的从服务器可以立刻升级为主服务器，且后面的从服务器不用做任何修改。需手动执行slaveof no one
### 1.20  哨兵模式
也就是自动完成反客为主的模式，设置哨兵节点，定时向主服务器、从服务器和其它哨兵发送信号当达到一定时间没有回应时认定主服务器主观下线，多个哨兵认定主观下线就会变成客观下线，然后哨兵通过投票算法选出新的主服务器。当原来的主服务器再次上线时会变成从服务器。选择条件为优先级高的到复制数据最多的再到runid小的。
### 1.21  集群
集群主要是为了解决写并发问题和海量数据的存储压力，redis的集群采用了去中心化的思想，集群至少有三个节点，然后将不同的数据分到集群中不同的服务器中，但是对于客户端来说，整个集群可以看成一个整体，可以连接任意一个节点进行操作，就像操作单一Redis实例一样，集群节点下还可以有从节点，当集群中的一个节点挂掉后，集群会提升它的某个从节点作为新的主节点加入集群
### 1.22  缓存穿透
指访问一个缓存和数据库中都不存在的key，由于这个key在缓存中不存在，则会到数据库中查询，数据库中也不存在该key，无法将数据添加到缓存中，所以每次都会访问数据库导致数据库压力增大
解决：
（1）将空key添加到缓存中
（2）使用布隆过滤器过滤空key。
（3）设置可访问的白名单
### 1.23  缓存击穿
指大量请求访问缓存中的一个key时，该key过期了，导致这些请求都去直接访问数据库，短时间大量的请求可能会将数据库击垮。
解决：
（1）预先将热门数据移入缓存并实时监控和调整key的过期时长
（2）添加互斥锁或分布式锁，只能有一个线程去访问数据库，将数据添加到缓存中后，其他线程直接从缓存中获取。
### 1.24  缓存雪崩
 指在系统运行过程中，缓存服务宕机或大量的key值同时过期，导致所有请求都直接访问数据库导致数据库压力增大
解决：
（1）构建多级缓存架构比如同时使用nginx缓存 和redis缓存
（2）加互斥锁，同一key值只允许一个线程去访问数据库，其余线程等待写入后直接从缓存中获取
（3）将缓存key失效的时间分散开
### 布隆过滤器

### 1.25  分布式锁

首先是分布式锁的应用场景：当多个并发的进程同一时刻要去修改某个资源时，我们希望该资源同一时刻只能一个进程修改。否则会发生混乱。
redis分布式锁的基本原理：利用setnx 每个key只能设置一次vlue的特性来实现锁的获取，后边给相同的key赋值的进程被阻塞，直到前面的进程完成操作后删掉key，也就是释放锁，后边的进程才可以成功赋值，然后进行他的工作。
但在实际的应用中往往会有很多情况出现：
（1）假如客户端1在获取到锁资源后宕机了，那么这个key会一直存在redis中，那么其他服务就永远无法获取到这个锁了。就发生了死锁。我们可以通过设置key的过期时间解决这个问题。即使当前客户端宕机了，key也会在过期时间到后被删除。
（2）但锁的过期时间要到了，但是我的工作还没有完成怎么办呢？redis已经帮我们实现了这个自动续时的功能。会给锁重新设置一个过期时间。
（3）如何防止释放其它服务的锁呢？设置的value带上自己的标识，要删某个key之前先get出来看一下这个value是不是自己添加的
（4）防止主服务器宕机：RedLock
### 1.26  Redis和MongoDB的区别

MongoDB是一个基于分布式文件存储的数据库。是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。
Redis和MongoDB是两种不同的数据库类型，它们在设计目标、数据模型、性能和使用场景上有很大的差异。
Redis是一种基于内存的键值存储数据库，支持高性能读写和支持数据持久化。它通常用于缓存、消息队列、实时分析等应用场景。
MongoDB是一种文档型数据库，支持高性能读写和分布式部署。它通常用于大规模数据存储、查询和分析。
总的来说，Redis更适合高性能场景，MongoDB更适合大规模数据存储和分析。

> 有复杂的事务选择MySQL，安全性高选择Oracle，缓存选择Redis，存储文档选择MongoDB。

### 1.26  Redis和Memcached的区别

Memcached只支持键值对的存储，也没有将数据持久化的功能，只专注于高性能的数据读写。Memcached提供的服务单一，运行所占内存更小，但更快速。

### 1.27  hash冲突和一致性hash

Redis用链地址法解决hash冲突

### 1.28  渐进式rehash

当hash表需要扩容时，一次性扩容需要停止服务，出现性能的卡顿。而Redis却可以边扩容边提供服务，这个过程称为渐进式rehash。在扩容期间，Redis需要维护两个hash表，较小的旧表和较大的新表，查询、删除和更新会结合两个表进行操作，添加则只会添加到新表中。

### 1.29  redis的发布和订阅

发布和订阅是一种消息模式，发布者向指定的频道（Channel）发送消息。任何订阅了该频道的客户端都会接收到这条消息。订阅者可以订阅一个或多个频道。（异步）

### 1.30  redis的限流

场景：每分钟限制用户只能访问100次。

> 这个场景可以通过Redis的有序集合Zset结合定时器（TTL）来实现。

1. 创建一个有序集合key，其中成员value1、value2等是用户ID，score是用户的访问时间戳（以秒为单位）。
2. 每次用户发起请求时，将其用户ID和当前时间戳添加到有序集合中。同时可以设置有序集合的最大长度，避免数据无限增长。
3. 使用定时器（TTL）定期清理有序集合中超过一分钟前的成员。
4. 在每次用户发起请求时，统计一分钟内集合里的用户的访问次数，如果超过了100则不允许当前用户继续访问。

### redis的key和scan

### redis的内存淘汰策略和内存优化

> 内存不足时，Redis会根据内存淘汰策略决定移除哪些键。

1. **LRU**（Least Recently Used）（默认）：移除最近最少使用的key。
2. **LFU**（Least Frequently Used，最不经常使用）：移除最不经常使用使用的key，每个key都会维护一个计数器，根据计数器来决定应该删除哪个key。
3. **TTL**（Time to Live）：移除具有过期时间的key。
4. **Random**：当其他策略无法决定移除哪个key时随机移除一个key。

### 1.40  分布式事务:

下游两个db使用redis, 需要更新这两个不同的db, 如何自己实现最终一致性

## 2  Redis 基础

### 2.1  常用命令

| 命令          | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| keys *        | 查看当前库所有key                                            |
| exists key    | 判断某个key是否存                                            |
| type key      | 查看你的key是什么类型                                        |
| del key       | 删除指定的key数据                                            |
| unlink key    | 根据value选择非阻塞删除， 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作 |
| expire key 10 | 为给定的key设置过期时间                                      |
| ttl key       | 查看还有多少秒过期，-1表示永不过期，-2表示已过期             |
| select        | 切换数据库                                                   |
| dbsize        | 查看当前数据库的key的数量                                    |
| flushdb       | 清空当前库                                                   |
| flushall      | 通杀全部库                                                   |

### 2.2  字符串String

> 一个key对应一个Value

| 命令               | 作用                                                         | 其它参数 |
| ------------------ | ------------------------------------------------------------ | -------- |
| set  key  value    | 添加键值对                                                   |          |
| get  key           | 查询对应键值                                                 |          |
| append  key  value | 将给定的value追加到原值的末尾                                |          |
| strlen  key        | 获得值的长度                                                 |          |
| setnx  key  value  | 只有在key 不存在时，设置 key 的值为value                     |          |
| incr  key          | 将 key 中储存的数字值增1，只能对数字值操作，如果为空，新增值为1 |          |
| decr  key          | 将 key 中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1 |          |
| incrby  key  1     | 将key 中储存的数字值增加1                                    |          |
| decrby  key  1     | 将key 中储存的数字值减去1                                    |          |

### 2.3  列表List

> 一个key对应多个value

| 命令                                  | 作用                                | 其它参数      |
| ------------------------------------- | ----------------------------------- | ------------- |
| lpush  key  value1  value2  ...       | 从左边插入一个或多个值              |               |
| rpush  key  value1  value2  ...       | 从右边插入一个或多个值              |               |
| lpop  key                             | 从左边取出一个值                    |               |
| rpop  key                             | 从右边取出一个值                    |               |
| lrang  key  start  stop               | 按照索引下标获得元素，下标从0开始   |               |
| lindex  key  idx                      | 按照索引下标获得元素，              |               |
| llen  key                             | 获得列表长度                        |               |
| linsert  key  before  value  newvalue | 在value的前面插入newvalue插入值     | 也可以是after |
| lrem  key  n  value                   | 从左到右删除n个value                |               |
| lset  key  index  value               | 将列表key下标为index的值替换成value |               |

### 2.4  集合Set

> 一个key对应多个value

| 命令                                   | 作用                                                      | 其它参数 |
| -------------------------------------- | --------------------------------------------------------- | -------- |
| sadd  key  value1  value2  ...         | 将一个或多个元素加入到集合 key 中，已经存在的元素将被忽略 |          |
| smembers  key                          | 取出该集合的所有值                                        |          |
| sismember  key  value                  | 判断集合key是否为含有该value值，有1，没有0                |          |
| scard  key                             | 返回该集合的元素个数                                      |          |
| srem  key  value1 value2  ...          | 删除集合中的某个元素（可以多个）                          |          |
| spop  key                              | 随机从该集合中删除并返回一个值                            |          |
| srandmember  key  n                    | 随机从该集合中取出n个值，不会从集合中删除                 |          |
| smove sourceSet  destinationSet  value | 把集合中一个值从一个集合移动到另一个集合                  |          |
| sinter  key1  key2                     | 返回两个集合的交集元素                                    |          |
| sunion  key1 key2                      | 返回两个集合的并集元素                                    |          |
| sdiff  key1  key2                      | 返回两个集合的差集元素(key1中有，key2中没有的)            |          |

### 2.5  哈希表Hash

> 一个key对应多个field，一个field对应一个value（用哈希函数映射）

| 命令                                           | 作用                                                         | 其它参数 |
| ---------------------------------------------- | ------------------------------------------------------------ | -------- |
| hset  key  field  value                        | 给key集合中的 field键赋值value                               |          |
| hget  key1  field                              | 从key1集合field取出value                                     |          |
| hmset  key1  field1  value1  field2  value2... | 批量设置hash的值                                             |          |
| hexists  key1  field                           | 查看哈希表 key 中，给定域 field 是否存在。                   |          |
| hkeys  key                                     | 列出该hash集合的所有field                                    |          |
| hvals  key                                     | 列出该hash集合的所有value                                    |          |
| hincrby  key  field  increment                 | 为哈希表 key 中的域 field 的值加上增量                       |          |
| hsetnx key  field  value                       | 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域field 不存在 . |          |

### 2.6  有序集合Zset

> 一个key对应多个value，一个value对应一个score

| 命令                                                         | 作用                                                         | 其它参数 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| zadd  key  score1  value1  score2  value2…                   | 将一个或多个 元素及其 score 值加入到有序集 key 当中          |          |
| zrange  key  start  stop [WITHSCORES]                        | 返回有序集 key 中，下标在start、stop之间的元素带WITHSCORES，可以让分数一起和值返回到结果集 |          |
| zrangebyscore key min  max \[withscores] \[limit offset count]] | 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 |          |
| zrangebyscore key max  min \[withscores] \[limit offset count]] | 同上，改为从大到小排列。                                     |          |
| zincrby  key  increment  value                               | 为元素的score加上增量                                        |          |
| zrem  key  value                                             | 删除该集合下，指定值的元素                                   |          |
| zcount  key  min  max                                        | 统计该集合，score区间内的元素个数                            |          |
| zrank  key  value                                            | 返回该key的score值在集合中的排名，从0开始。                  |          |

